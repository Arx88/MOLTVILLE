import express from 'express';
import { requireAdminKey } from '../utils/adminAuth.js';
import { requireAgentKey } from '../utils/agentAuth.js';
import { requireViewerKey } from '../utils/viewerAuth.js';
import { config } from '../utils/config.js';
import { JoiHelpers, validateBody } from '../utils/validation.js';
import {
  getSnapshotStats,
  loadSnapshotFile,
  resolveSnapshotPath,
  saveSnapshotFile
} from '../utils/snapshot.js';
import { loadLatestSnapshotDb, saveSnapshotDb } from '../utils/snapshotDb.js';
import { buildUrbanNeedsHeatmap, getDistrictNeeds } from '../core/UrbanNeedsAnalyzer.js';

const router = express.Router();
const { Joi } = JoiHelpers;

const worldProposalSchema = Joi.object({
  agentId: Joi.string().trim().required(),
  templateId: Joi.string().trim().allow(null, ''),
  customName: Joi.string().allow('').default(''),
  districtId: Joi.string().trim().allow(null, ''),
  type: Joi.string().trim().allow(null, ''),
  proposalType: Joi.string().trim().valid('ciudadana', 'inversion_privada', 'proyecto_estatal', 'cooperativa').default('ciudadana'),
  reason: Joi.string().allow('').default(''),
  cost: Joi.number().allow(null),
  coProposers: Joi.array().items(Joi.string().trim()).default([]),
  funding: Joi.object().unknown(true).optional()
});

router.get('/state', requireViewerKey, async (req, res) => {
  try {
    const { worldState, cityMoodManager, eventManager } = req.app.locals;
    res.json({
      ...worldState.getFullState(),
      mood: cityMoodManager.getSummary(),
      events: eventManager?.getSummary?.() || []
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.get('/needs/heatmap', requireViewerKey, async (req, res) => {
  try {
    const { worldState, economyManager } = req.app.locals;
    const heatmap = buildUrbanNeedsHeatmap({ worldState, economyManager });
    res.json({ success: true, ...heatmap });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

router.get('/districts/:districtId/needs', requireViewerKey, async (req, res) => {
  try {
    const { districtId } = req.params;
    const { worldState, economyManager } = req.app.locals;
    const district = getDistrictNeeds({ worldState, economyManager, districtId });
    if (!district) {
      return res.status(404).json({ success: false, error: 'District not found' });
    }
    return res.json({ success: true, district });
  } catch (error) {
    return res.status(500).json({ success: false, error: error.message });
  }
});

router.get('/proposals', requireViewerKey, async (req, res) => {
  try {
    const { votingManager } = req.app.locals;
    const status = typeof req.query.status === 'string' ? req.query.status : null;
    const districtId = typeof req.query.districtId === 'string' ? req.query.districtId : null;
    return res.json({
      success: true,
      proposals: votingManager.listProposals({ status, districtId })
    });
  } catch (error) {
    return res.status(500).json({ success: false, error: error.message });
  }
});

router.post('/propose', requireAgentKey({
  allowAdmin: true,
  useSuccessResponse: true,
  getAgentId: (req) => req.body?.agentId
}), validateBody(worldProposalSchema), async (req, res) => {
  try {
    const { votingManager, moltbotRegistry } = req.app.locals;
    const { agentId } = req.body;
    const agent = moltbotRegistry?.getAgent?.(agentId);
    if (!agent) {
      return res.status(400).json({ success: false, error: 'Agent not found' });
    }

    const result = votingManager.proposeBuilding({
      agentId,
      templateId: req.body.templateId || null,
      customName: req.body.customName || '',
      districtId: req.body.districtId || null,
      type: req.body.type || null,
      proposalType: req.body.proposalType || 'ciudadana',
      reason: req.body.reason || '',
      cost: req.body.cost,
      coProposers: req.body.coProposers || [],
      funding: req.body.funding || null
    });

    return res.status(201).json({ success: true, ...result });
  } catch (error) {
    return res.status(400).json({ success: false, error: error.message });
  }
});

router.get('/buildings', requireViewerKey, async (req, res) => {
  try {
    const { worldState } = req.app.locals;
    res.json(worldState.buildings);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.get('/lots', requireViewerKey, async (req, res) => {
  try {
    const { worldState } = req.app.locals;
    res.json(worldState.lots);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.get('/buildings/:buildingId', requireViewerKey, async (req, res) => {
  try {
    const { buildingId } = req.params;
    const { worldState } = req.app.locals;

    const building = worldState.buildings.find((entry) => entry.id === buildingId);
    if (!building) {
      return res.status(404).json({ error: 'Building not found' });
    }

    return res.json(building);
  } catch (error) {
    return res.status(500).json({ error: error.message });
  }
});

router.get('/social-network', requireViewerKey, async (req, res) => {
  try {
    const { interactionEngine } = req.app.locals;
    const network = interactionEngine.getSocialNetwork();
    res.json(network);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.get('/conversations', requireViewerKey, async (req, res) => {
  try {
    const { interactionEngine } = req.app.locals;
    const conversations = interactionEngine.getActiveConversations();
    res.json(conversations);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.post('/snapshot', requireAdminKey, async (req, res) => {
  try {
    const {
      worldState,
      moltbotRegistry,
      actionQueue,
      economyManager,
      eventManager,
      interactionEngine,
      aestheticsManager,
      cityMoodManager,
      governanceManager,
      votingManager,
      coordinationManager
    } = req.app.locals;

    const snapshot = {
      ...worldState.createSnapshot(),
      registry: moltbotRegistry.createSnapshot(),
      actionQueue: actionQueue.createSnapshot(),
      economy: economyManager.createSnapshot(),
      events: eventManager.createSnapshot(),
      conversations: interactionEngine.createSnapshot(),
      aesthetics: aestheticsManager.createSnapshot(),
      mood: cityMoodManager.createSnapshot(),
      governance: governanceManager.createSnapshot(),
      voting: votingManager.createSnapshot(),
      coordination: coordinationManager.createSnapshot()
    };

    const snapshotPath = resolveSnapshotPath(config.worldSnapshotPath);
    await saveSnapshotFile(snapshotPath, snapshot, {
      archiveDir: config.worldSnapshotArchiveDir,
      retention: config.worldSnapshotArchiveRetention,
      checksum: config.worldSnapshotArchiveChecksum
    });

    if (req.app.locals.db) {
      await saveSnapshotDb(req.app.locals.db, snapshot);
    }

    res.json({ success: true, path: snapshotPath, createdAt: snapshot.createdAt });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

router.post('/snapshot/restore', requireAdminKey, async (req, res) => {
  try {
    const {
      worldState,
      moltbotRegistry,
      actionQueue,
      economyManager,
      eventManager,
      interactionEngine,
      aestheticsManager,
      cityMoodManager,
      governanceManager,
      votingManager,
      coordinationManager
    } = req.app.locals;

    const snapshotPath = resolveSnapshotPath(config.worldSnapshotPath);
    const snapshot = config.worldSnapshotSource === 'db'
      ? await loadLatestSnapshotDb(req.app.locals.db)
      : await loadSnapshotFile(snapshotPath);

    worldState.loadSnapshot(snapshot);
    moltbotRegistry.loadSnapshot(snapshot.registry);
    actionQueue.loadSnapshot(snapshot.actionQueue);
    economyManager.loadSnapshot(snapshot.economy);
    eventManager.loadSnapshot(snapshot.events);
    interactionEngine.loadSnapshot(snapshot.conversations);
    aestheticsManager.loadSnapshot(snapshot.aesthetics);
    cityMoodManager.loadSnapshot(snapshot.mood);
    governanceManager.loadSnapshot(snapshot.governance);
    votingManager.loadSnapshot(snapshot.voting);
    coordinationManager.loadSnapshot(snapshot.coordination);

    res.json({ success: true, restoredAt: Date.now() });
  } catch (error) {
    if (error.code === 'ENOENT') {
      return res.status(404).json({ success: false, error: 'Snapshot not found' });
    }
    return res.status(500).json({ success: false, error: error.message });
  }
});

router.get('/snapshot/status', requireAdminKey, async (req, res) => {
  try {
    const snapshotPath = resolveSnapshotPath(config.worldSnapshotPath);
    const stats = await getSnapshotStats(snapshotPath);
    res.json({ exists: true, path: snapshotPath, ...stats });
  } catch (error) {
    if (error.code === 'ENOENT') {
      return res.json({ exists: false, path: resolveSnapshotPath(config.worldSnapshotPath) });
    }
    return res.status(500).json({ success: false, error: error.message });
  }
});

export default router;
