import { logger } from '../utils/logger.js';
import { BUILDING_CATALOG, filterCatalogByDistrict, getCatalogForPopulation } from './BuildingCatalog.js';

export class VotingManager {
  constructor(worldState, io, options = {}) {
    this.worldState = worldState;
    this.io = io;
    this.db = options.db || null;
    this.economyManager = options.economyManager || null;
    this.governanceManager = options.governanceManager || null;
    this.catalog = options.catalog || BUILDING_CATALOG;
    this.voteDurationMs = parseInt(process.env.BUILDING_VOTE_DURATION_MS, 10) || 86400000;
    this.voteOptionsCount = parseInt(process.env.BUILDING_VOTE_OPTIONS, 10) || 4;
    this.maxProposalsPerVote = parseInt(process.env.BUILDING_VOTE_PROPOSALS, 10) || 1;
    this.proposalTtlMs = parseInt(process.env.BUILDING_PROPOSAL_TTL_MS, 10) || 604800000;
    this.proposalSupportThreshold = parseInt(process.env.BUILDING_PROPOSAL_SUPPORT_THRESHOLD, 10) || 1;
    this.proposalCriticRejectThreshold = parseInt(process.env.BUILDING_PROPOSAL_CRITIC_REJECT_THRESHOLD, 10) || 3;
    this.currentVote = null;
    this.pendingProposals = [];
    this.voteHistory = [];
  }

  async initializeFromDb() {
    if (!this.db) return;
    const result = await this.db.query(
      "SELECT * FROM vote_state WHERE status = 'open' ORDER BY starts_at DESC LIMIT 1"
    );
    if (!result.rows.length) return;
    const row = result.rows[0];
    this.currentVote = {
      id: row.vote_id,
      lotId: row.lot_id,
      options: row.options,
      votes: row.votes,
      voters: new Set(row.voters || []),
      startsAt: Number(row.starts_at),
      endsAt: Number(row.ends_at)
    };

    const proposals = await this.db.query(
      "SELECT * FROM vote_proposals WHERE status IN ('pending', 'approved') ORDER BY created_at ASC"
    );
    this.pendingProposals = proposals.rows.map(row => ({
      id: row.proposal_id,
      agentId: row.agent_id,
      templateId: row.template_id,
      name: row.name,
      type: row.type,
      district: row.district_id,
      createdAt: Number(row.created_at),
      proposalType: 'ciudadana',
      reason: '',
      cost: null,
      supporters: new Set(),
      critics: new Set(),
      supportReasons: [],
      criticReasons: [],
      coProposers: [],
      status: row.status || 'pending',
      funding: null,
      approvedAt: null,
      veto: null
    }));
  }

  startVote() {
    if (this.currentVote) return this.currentVote;
    const availableLots = this.worldState.lots;
    if (!availableLots.length) {
      logger.info('Voting: no available lots for construction.');
      return null;
    }
    const lot = availableLots[Math.floor(Math.random() * availableLots.length)];
    const districtId = lot.district || 'central';
    const population = this.worldState.agents?.size || 0;
    const options = this.buildVoteOptions(districtId, population);
    const now = Date.now();
    this.currentVote = {
      id: `vote-${now}`,
      lotId: lot.id,
      options,
      votes: {},
      voters: new Set(),
      startsAt: now,
      endsAt: now + this.voteDurationMs
    };
    this.persistVote('open');
    this.io.emit('vote:started', this.getVoteSummary());
    logger.info(`Voting: started ${this.currentVote.id}`);
    return this.currentVote;
  }

  buildVoteOptions(districtId, population) {
    const proposals = this.consumeProposals(districtId);
    const baseCatalog = filterCatalogByDistrict(
      getCatalogForPopulation(population),
      districtId
    );
    const fallbackCatalog = this.catalog.length ? this.catalog : BUILDING_CATALOG;
    const pool = baseCatalog.length ? baseCatalog : fallbackCatalog;
    const options = proposals.map(proposal => ({
      id: proposal.id,
      name: proposal.name,
      type: proposal.type,
      source: 'proposal',
      templateId: proposal.templateId
    }));
    const usedIds = new Set(options.map(option => option.templateId || option.id));

    while (options.length < this.voteOptionsCount && pool.length) {
      const candidate = pool[Math.floor(Math.random() * pool.length)];
      if (usedIds.has(candidate.id)) continue;
      options.push({
        id: candidate.id,
        name: candidate.name,
        type: candidate.type,
        source: 'catalog',
        templateId: candidate.id
      });
      usedIds.add(candidate.id);
    }
    return options.slice(0, this.voteOptionsCount);
  }

  listCatalog() {
    return this.catalog;
  }

  resolveProposalTemplate({ templateId = null, type = null, customName = '' }) {
    const sanitizedName = String(customName || '').trim();
    let resolvedType = type ? String(type).trim() : '';
    let resolvedName = sanitizedName;
    let resolvedTemplateId = templateId ? String(templateId).trim() : null;

    if (resolvedTemplateId) {
      const template = this.catalog.find(entry => entry.id === resolvedTemplateId);
      if (!template) throw new Error('Template not found');
      resolvedType = template.type;
      resolvedName = sanitizedName ? sanitizedName.slice(0, 60) : template.name;
    } else {
      if (!resolvedType) throw new Error('Building type required');
      if (!resolvedName) throw new Error('Custom name required');
      resolvedTemplateId = null;
      resolvedName = resolvedName.slice(0, 60);
    }

    return {
      templateId: resolvedTemplateId,
      type: resolvedType,
      name: resolvedName
    };
  }

  getProposal(proposalId) {
    return this.pendingProposals.find((proposal) => proposal.id === proposalId) || null;
  }

  toPublicProposal(proposal) {
    if (!proposal) return null;
    return {
      id: proposal.id,
      agentId: proposal.agentId,
      templateId: proposal.templateId,
      name: proposal.name,
      type: proposal.type,
      district: proposal.district,
      createdAt: proposal.createdAt,
      proposalType: proposal.proposalType || 'ciudadana',
      reason: proposal.reason || '',
      cost: proposal.cost ?? null,
      status: proposal.status || 'pending',
      supportCount: proposal.supporters instanceof Set ? proposal.supporters.size : 0,
      criticCount: proposal.critics instanceof Set ? proposal.critics.size : 0,
      supporters: proposal.supporters instanceof Set ? Array.from(proposal.supporters) : [],
      critics: proposal.critics instanceof Set ? Array.from(proposal.critics) : [],
      supportReasons: Array.isArray(proposal.supportReasons) ? proposal.supportReasons : [],
      criticReasons: Array.isArray(proposal.criticReasons) ? proposal.criticReasons : [],
      coProposers: Array.isArray(proposal.coProposers) ? proposal.coProposers : [],
      funding: proposal.funding || null,
      approvedAt: proposal.approvedAt || null,
      veto: proposal.veto || null
    };
  }

  listProposals({ status = null, districtId = null } = {}) {
    return this.pendingProposals
      .filter((proposal) => {
        if (status && proposal.status !== status) return false;
        if (districtId && proposal.district && proposal.district !== districtId) return false;
        return true;
      })
      .map((proposal) => this.toPublicProposal(proposal))
      .sort((a, b) => Number(b.createdAt || 0) - Number(a.createdAt || 0));
  }

  validateProposalType({ proposalType, agentId, cost, coProposers }) {
    const normalized = String(proposalType || 'ciudadana').trim().toLowerCase();
    const allowed = new Set(['ciudadana', 'inversion_privada', 'proyecto_estatal', 'cooperativa']);
    if (!allowed.has(normalized)) {
      throw new Error('proposalType invalid');
    }

    if (normalized === 'proyecto_estatal') {
      const presidentId = this.governanceManager?.currentPresident?.agentId || null;
      if (!presidentId || presidentId !== agentId) {
        throw new Error('Only current president can create proyecto_estatal proposals');
      }
    }

    if (normalized === 'inversion_privada') {
      const amount = Number(cost || 0);
      if (!Number.isFinite(amount) || amount <= 0) {
        throw new Error('inversion_privada requires a positive cost');
      }
      const balance = Number(this.economyManager?.getBalance?.(agentId) || 0);
      if (balance < amount) {
        throw new Error('Insufficient balance for inversion_privada');
      }
    }

    if (normalized === 'cooperativa') {
      const participants = Array.isArray(coProposers) ? coProposers.filter(Boolean) : [];
      const unique = new Set([...participants, agentId]);
      if (unique.size < 3) {
        throw new Error('cooperativa requires at least 3 participants');
      }
    }

    return normalized;
  }

  proposeBuilding({
    agentId,
    templateId = null,
    customName = '',
    districtId = null,
    type = null,
    proposalType = 'ciudadana',
    reason = '',
    cost = null,
    coProposers = [],
    funding = null
  }) {
    if (!agentId) throw new Error('Agent ID required');
    const resolved = this.resolveProposalTemplate({ templateId, type, customName });
    const normalizedType = this.validateProposalType({
      proposalType,
      agentId,
      cost,
      coProposers
    });

    const proposal = {
      id: `proposal-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
      agentId,
      templateId: resolved.templateId,
      name: resolved.name,
      type: resolved.type,
      district: districtId,
      createdAt: Date.now(),
      proposalType: normalizedType,
      reason: String(reason || '').trim().slice(0, 240),
      cost: Number.isFinite(Number(cost)) ? Number(cost) : null,
      supporters: new Set([agentId]),
      critics: new Set(),
      supportReasons: [],
      criticReasons: [],
      coProposers: Array.isArray(coProposers)
        ? Array.from(new Set(coProposers.filter(Boolean).map((entry) => String(entry).trim())))
        : [],
      status: normalizedType === 'proyecto_estatal' ? 'approved' : 'pending',
      funding: funding && typeof funding === 'object' ? { ...funding } : null,
      approvedAt: null,
      veto: null
    };

    if (proposal.proposalType === 'inversion_privada') {
      proposal.status = 'approved';
      proposal.approvedAt = Date.now();
      const amount = Number(proposal.cost || 0);
      this.economyManager.decrementBalance(agentId, amount, `private_build_investment:${proposal.id}`);
      const building = this.constructBuildingDirect(proposal, { source: 'private_investment' });
      this.pendingProposals.push(proposal);
      this.persistProposal(proposal);
      proposal.status = 'used';
      this.persistProposalStatus(proposal.id, 'used');
      return { proposal: this.toPublicProposal(proposal), building, mode: 'direct' };
    }

    if (proposal.proposalType === 'proyecto_estatal') {
      const amount = Number(proposal.cost || 0);
      if (amount > 0) {
        const treasuryBalance = Number(this.economyManager?.getTreasurySummary?.().balance || 0);
        if (treasuryBalance < amount) {
          throw new Error('Insufficient treasury balance for proyecto_estatal');
        }
        this.economyManager.recordTreasury(-amount, `state_project:${proposal.id}`);
      }
      proposal.approvedAt = Date.now();
      const building = this.constructBuildingDirect(proposal, { source: 'state_project' });
      this.pendingProposals.push(proposal);
      this.persistProposal(proposal);
      proposal.status = 'used';
      this.persistProposalStatus(proposal.id, 'used');
      return { proposal: this.toPublicProposal(proposal), building, mode: 'direct' };
    }

    this.pendingProposals.push(proposal);
    this.persistProposal(proposal);
    return { proposal: this.toPublicProposal(proposal), building: null, mode: 'vote' };
  }

  constructBuildingDirect(proposal, { source = 'proposal' } = {}) {
    const districtId = proposal?.district || null;
    const availableLots = (this.worldState?.lots || []).filter((lot) => !districtId || lot.district === districtId);
    const lot = availableLots[0] || this.worldState?.lots?.[0];
    if (!lot) {
      throw new Error('No available lots for direct construction');
    }

    const building = this.worldState.addBuildingFromLot({
      id: `building-${Date.now()}`,
      name: proposal.name,
      type: proposal.type,
      lotId: lot.id
    });

    if (this.economyManager) {
      this.economyManager.registerBuilding(building);
    }

    this.io.emit('building:constructed', {
      ...building,
      source,
      proposalId: proposal.id
    });

    this.trackHistory({
      voteId: `direct-${proposal.id}`,
      lotId: lot.id,
      winner: {
        id: proposal.id,
        name: proposal.name,
        type: proposal.type,
        source
      },
      totalVotes: 0
    });

    return building;
  }

  supportProposal({ proposalId, agentId, support = true, reason = '' }) {
    const proposal = this.getProposal(proposalId);
    if (!proposal) throw new Error('Proposal not found');
    if (!agentId) throw new Error('Agent ID required');
    if (proposal.status !== 'pending' && proposal.status !== 'approved') {
      throw new Error(`Proposal is ${proposal.status}`);
    }

    const normalizedAgent = String(agentId).trim();
    if (support) {
      proposal.supporters.add(normalizedAgent);
      proposal.critics.delete(normalizedAgent);
      if (reason) {
        proposal.supportReasons.push({
          agentId: normalizedAgent,
          reason: String(reason).trim().slice(0, 180),
          at: Date.now()
        });
      }
    } else {
      proposal.critics.add(normalizedAgent);
      proposal.supporters.delete(normalizedAgent);
      if (reason) {
        proposal.criticReasons.push({
          agentId: normalizedAgent,
          reason: String(reason).trim().slice(0, 180),
          at: Date.now()
        });
      }
    }

    this.refreshProposalStatus(proposal);
    this.persistProposalStatus(proposal.id, proposal.status);
    return this.toPublicProposal(proposal);
  }

  vetoProposal({ proposalId, presidentAgentId, reason = '' }) {
    const proposal = this.getProposal(proposalId);
    if (!proposal) throw new Error('Proposal not found');
    const presidentId = this.governanceManager?.currentPresident?.agentId || null;
    if (!presidentId || presidentId !== presidentAgentId) {
      throw new Error('Only current president can veto proposals');
    }
    proposal.status = 'vetoed';
    proposal.veto = {
      by: presidentAgentId,
      reason: String(reason || '').trim().slice(0, 180),
      at: Date.now()
    };
    this.persistProposalStatus(proposal.id, 'vetoed');
    return this.toPublicProposal(proposal);
  }

  refreshProposalStatus(proposal, now = Date.now()) {
    if (!proposal) return 'pending';
    if (!(proposal.supporters instanceof Set)) {
      proposal.supporters = new Set(Array.isArray(proposal.supporters) ? proposal.supporters : []);
    }
    if (!(proposal.critics instanceof Set)) {
      proposal.critics = new Set(Array.isArray(proposal.critics) ? proposal.critics : []);
    }
    if (!Array.isArray(proposal.supportReasons)) {
      proposal.supportReasons = [];
    }
    if (!Array.isArray(proposal.criticReasons)) {
      proposal.criticReasons = [];
    }
    if (!Array.isArray(proposal.coProposers)) {
      proposal.coProposers = [];
    }
    if (!proposal.proposalType) {
      // Backward compatibility with legacy proposal objects used by tests/snapshots.
      proposal.proposalType = 'ciudadana';
      if (proposal.status === undefined) {
        proposal.status = 'approved';
        return proposal.status;
      }
    }
    if (proposal.status === 'vetoed' || proposal.status === 'used') return proposal.status;
    if (now - proposal.createdAt > this.proposalTtlMs) {
      proposal.status = 'expired';
      return proposal.status;
    }
    const supports = proposal.supporters instanceof Set ? proposal.supporters.size : 0;
    const critics = proposal.critics instanceof Set ? proposal.critics.size : 0;
    if (critics >= this.proposalCriticRejectThreshold && critics > supports) {
      proposal.status = 'rejected';
      return proposal.status;
    }
    if (proposal.proposalType === 'cooperativa') {
      const participants = new Set([proposal.agentId, ...(proposal.coProposers || [])]);
      if (participants.size >= 3 && supports >= this.proposalSupportThreshold) {
        proposal.status = 'approved';
        proposal.approvedAt = proposal.approvedAt || now;
        return proposal.status;
      }
      proposal.status = 'pending';
      return proposal.status;
    }
    if (supports >= this.proposalSupportThreshold) {
      proposal.status = 'approved';
      proposal.approvedAt = proposal.approvedAt || now;
      return proposal.status;
    }
    proposal.status = 'pending';
    return proposal.status;
  }

  consumeProposals(districtId) {
    const now = Date.now();
    const active = [];
    const closed = [];
    this.pendingProposals.forEach(proposal => {
      const status = this.refreshProposalStatus(proposal, now);
      if (status === 'approved' || status === 'pending') {
        active.push(proposal);
      } else {
        closed.push(proposal);
      }
    });
    closed.forEach((proposal) => this.persistProposalStatus(proposal.id, proposal.status));
    const [matching, others] = active.reduce(
      (acc, proposal) => {
        const target = (!proposal.district || proposal.district === districtId) && proposal.status === 'approved'
          ? acc[0]
          : acc[1];
        target.push(proposal);
        return acc;
      },
      [[], []]
    );
    const selected = matching.slice(0, this.maxProposalsPerVote);
    const selectedIds = new Set(selected.map(item => item.id));
    const remaining = [...matching.slice(this.maxProposalsPerVote), ...others]
      .filter(item => !selectedIds.has(item.id));
    this.pendingProposals = remaining;
    selected.forEach((proposal) => {
      proposal.status = 'used';
      this.persistProposalStatus(proposal.id, 'used');
    });
    return selected;
  }

  castVote(agentId, optionId) {
    if (!this.currentVote) {
      throw new Error('No active vote');
    }
    if (this.currentVote.voters.has(agentId)) {
      throw new Error('Agent already voted');
    }
    const option = this.currentVote.options.find(item => item.id === optionId);
    if (!option) {
      throw new Error('Invalid option');
    }
    this.currentVote.voters.add(agentId);
    this.currentVote.votes[optionId] = (this.currentVote.votes[optionId] || 0) + 1;
    this.persistVote('open');
    return this.getVoteSummary();
  }

  tick() {
    if (!this.currentVote) {
      this.startVote();
      return;
    }
    if (Date.now() >= this.currentVote.endsAt) {
      this.closeVote();
      this.startVote();
    }
  }

  closeVote() {
    const vote = this.currentVote;
    if (!vote) return null;
    const winningOption = this.selectWinner(vote);
    const building = this.worldState.addBuildingFromLot({
      id: `building-${Date.now()}`,
      name: winningOption.name,
      type: winningOption.type,
      lotId: vote.lotId
    });
    if (this.economyManager) {
      this.economyManager.registerBuilding(building);
    }
    const result = {
      voteId: vote.id,
      lotId: vote.lotId,
      winner: winningOption,
      totalVotes: Object.values(vote.votes).reduce((sum, count) => sum + count, 0)
    };
    this.io.emit('vote:closed', result);
    this.io.emit('building:constructed', building);
    logger.info(`Voting: closed ${vote.id} winner ${winningOption.id}`);
    this.persistVote('closed', winningOption);
    this.trackHistory(result);
    this.currentVote = null;
    return result;
  }

  selectWinner(vote) {
    const tally = vote.options.map(option => ({
      ...option,
      votes: vote.votes[option.id] || 0
    }));
    tally.sort((a, b) => b.votes - a.votes);
    return tally[0] || vote.options[0];
  }

  getVoteSummary() {
    if (!this.currentVote) return null;
    return {
      id: this.currentVote.id,
      lotId: this.currentVote.lotId,
      options: this.currentVote.options.map(option => ({
        ...option,
        votes: this.currentVote.votes[option.id] || 0
      })),
      startsAt: this.currentVote.startsAt,
      endsAt: this.currentVote.endsAt
    };
  }

  trackHistory(result) {
    if (!result) return;
    const entry = {
      voteId: result.voteId,
      lotId: result.lotId,
      winner: result.winner,
      totalVotes: result.totalVotes,
      closedAt: Date.now()
    };
    this.voteHistory.unshift(entry);
    this.voteHistory = this.voteHistory.slice(0, 20);
  }

  async getVoteHistory(limit = 5) {
    if (!this.db) {
      return this.voteHistory.slice(0, limit);
    }
    const result = await this.db.query(
      "SELECT vote_id, lot_id, winner, ends_at FROM vote_state WHERE status = 'closed' ORDER BY ends_at DESC LIMIT $1",
      [limit]
    );
    return result.rows.map(row => ({
      voteId: row.vote_id,
      lotId: row.lot_id,
      winner: row.winner,
      closedAt: Number(row.ends_at)
    }));
  }

  persistProposal(proposal) {
    if (!this.db || !proposal) return;
    this.db.query(
      `INSERT INTO vote_proposals (proposal_id, agent_id, template_id, name, type, district_id, status, created_at)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
       ON CONFLICT (proposal_id) DO NOTHING`,
      [
        proposal.id,
        proposal.agentId,
        proposal.templateId,
        proposal.name,
        proposal.type,
        proposal.district,
        proposal.status || 'pending',
        proposal.createdAt
      ]
    ).catch(error => logger.error('Vote proposal persist failed:', error));
  }

  persistProposalStatus(proposalId, status) {
    if (!this.db || !proposalId) return;
    this.db.query(
      `UPDATE vote_proposals SET status = $2, used_at = NOW() WHERE proposal_id = $1`,
      [proposalId, status]
    ).catch(error => logger.error('Vote proposal update failed:', error));
  }

  persistVote(status, winner = null) {
    if (!this.db || !this.currentVote) return;
    const vote = this.currentVote;
    this.db.query(
      `INSERT INTO vote_state (vote_id, lot_id, options, votes, voters, starts_at, ends_at, status, winner)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
       ON CONFLICT (vote_id) DO UPDATE SET
         options = EXCLUDED.options,
         votes = EXCLUDED.votes,
         voters = EXCLUDED.voters,
         status = EXCLUDED.status,
         winner = EXCLUDED.winner`,
      [
        vote.id,
        vote.lotId,
        vote.options,
        vote.votes,
        Array.from(vote.voters),
        vote.startsAt,
        vote.endsAt,
        status,
        winner
      ]
    ).catch(error => logger.error('Vote persist failed:', error));
  }

  createSnapshot() {
    return {
      currentVote: this.currentVote
        ? {
            id: this.currentVote.id,
            lotId: this.currentVote.lotId,
            options: this.currentVote.options.map(option => ({ ...option })),
            votes: { ...this.currentVote.votes },
            voters: Array.from(this.currentVote.voters),
            startsAt: this.currentVote.startsAt,
            endsAt: this.currentVote.endsAt
          }
        : null,
      pendingProposals: this.pendingProposals.map(proposal => ({
        ...proposal,
        supporters: Array.from(proposal.supporters || []),
        critics: Array.from(proposal.critics || [])
      })),
      voteHistory: this.voteHistory.map(entry => ({ ...entry }))
    };
  }

  loadSnapshot(snapshot) {
    if (!snapshot) return;
    if (snapshot.currentVote) {
      const vote = snapshot.currentVote;
      this.currentVote = {
        id: vote.id,
        lotId: vote.lotId,
        options: (vote.options || []).map(option => ({ ...option })),
        votes: vote.votes || {},
        voters: new Set(vote.voters || []),
        startsAt: Number(vote.startsAt),
        endsAt: Number(vote.endsAt)
      };
    } else {
      this.currentVote = null;
    }
    this.pendingProposals = Array.isArray(snapshot.pendingProposals)
      ? snapshot.pendingProposals.map((proposal) => ({
          ...proposal,
          supporters: new Set(proposal.supporters || []),
          critics: new Set(proposal.critics || []),
          supportReasons: Array.isArray(proposal.supportReasons) ? proposal.supportReasons : [],
          criticReasons: Array.isArray(proposal.criticReasons) ? proposal.criticReasons : [],
          coProposers: Array.isArray(proposal.coProposers) ? proposal.coProposers : [],
          proposalType: proposal.proposalType || 'ciudadana',
          status: proposal.status || 'pending'
        }))
      : [];
    this.voteHistory = Array.isArray(snapshot.voteHistory)
      ? snapshot.voteHistory.map(entry => ({ ...entry }))
      : [];
  }
}
